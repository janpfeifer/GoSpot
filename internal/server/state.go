package server

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"sync"
	"time"

	"github.com/coder/websocket"
	"github.com/coder/websocket/wsjson"
	"github.com/janpfeifer/GoSpot/internal/game"
	"k8s.io/klog/v2"
)

// ServerState manages all active tables and WebSockets.
type ServerState struct {
	mu           sync.RWMutex
	Tables       map[string]*game.Table
	TableClients map[string]map[*websocket.Conn]string // TableID -> Conn -> PlayerID
}

// NewServerState creates a new ServerState.
func NewServerState() *ServerState {
	return &ServerState{
		Tables:       make(map[string]*game.Table),
		TableClients: make(map[string]map[*websocket.Conn]string),
	}
}

// HandleWS handles an incoming WebSocket connection.
func (s *ServerState) HandleWS(w http.ResponseWriter, r *http.Request) {
	conn, err := websocket.Accept(w, r, &websocket.AcceptOptions{
		InsecureSkipVerify: true,
	})
	if err != nil {
		klog.Errorf("Failed to accept websocket: %v", err)
		return
	}
	defer conn.CloseNow()

	// 1. Wait for join message from client
	var msg game.WsMessage
	err = wsjson.Read(r.Context(), conn, &msg)
	if err != nil {
		klog.Errorf("Failed to read initial msg: %v", err)
		return
	}

	if msg.Type != game.MsgTypeJoin {
		klog.Errorf("Expected Join message, got: %s", msg.Type)
		return
	}

	// Parsing payload
	payloadBytes, err := json.Marshal(msg.Payload)
	if err != nil {
		return
	}
	var joinPayload game.JoinPayload
	if err := json.Unmarshal(payloadBytes, &joinPayload); err != nil {
		klog.Errorf("Invalid Join payload: %v", err)
		return
	}

	tableID := joinPayload.TableID
	player := joinPayload.Player

	// Ensure player ID
	if player.ID == "" { // Should be generated by client, but fallback
		player.ID = fmt.Sprintf("%d", time.Now().UnixNano())
	}

	s.joinTable(tableID, &player, conn)

	// Disconnect handler
	defer s.leaveTable(tableID, conn)

	// 2. Read loop
	for {
		err = wsjson.Read(r.Context(), conn, &msg)
		if websocket.CloseStatus(err) == websocket.StatusNormalClosure || websocket.CloseStatus(err) == websocket.StatusGoingAway {
			break
		}
		if err != nil {
			klog.Errorf("WS read error: %v", err)
			break
		}

		s.handleMessage(tableID, conn, player.ID, msg)
	}
}

func (s *ServerState) joinTable(tableID string, player *game.Player, conn *websocket.Conn) {
	s.mu.Lock()
	defer s.mu.Unlock()

	table, ok := s.Tables[tableID]
	if !ok {
		// Auto-create table
		table = &game.Table{
			ID:      tableID,
			Name:    tableID, // Client can optionally rename later
			Players: make(map[string]*game.Player),
		}
		s.Tables[tableID] = table
		s.TableClients[tableID] = make(map[*websocket.Conn]string)
	}

	table.Players[player.ID] = player
	s.TableClients[tableID][conn] = player.ID

	s.broadcastStateLocked(tableID)
}

func (s *ServerState) leaveTable(tableID string, conn *websocket.Conn) {
	s.mu.Lock()
	defer s.mu.Unlock()

	clients, ok := s.TableClients[tableID]
	if !ok {
		return
	}

	playerID, ok := clients[conn]
	if ok {
		delete(clients, conn)
		table := s.Tables[tableID]
		if table != nil {
			delete(table.Players, playerID)
			// If table is empty, we could delete it, but memory is small
			if len(table.Players) == 0 {
				delete(s.Tables, tableID)
				delete(s.TableClients, tableID)
			} else {
				s.broadcastStateLocked(tableID)
			}
		}
	}
}

func (s *ServerState) handleMessage(tableID string, conn *websocket.Conn, playerID string, msg game.WsMessage) {
	s.mu.Lock()
	defer s.mu.Unlock()

	table, ok := s.Tables[tableID]
	if !ok {
		return
	}

	switch msg.Type {
	case game.MsgTypeStart:
		if len(table.Players) >= 2 {
			table.Started = true
			s.broadcastStateLocked(tableID)
		}
	}
}

// broadcastStateLocked broadcasts table state to all connections. Assumes m.mu is locked.
func (s *ServerState) broadcastStateLocked(tableID string) {
	table := s.Tables[tableID]
	stateMsg := game.WsMessage{
		Type: game.MsgTypeState,
		Payload: game.StatePayload{
			Table: *table,
		},
	}

	for conn := range s.TableClients[tableID] {
		// Non-blocking quick send, or run in goroutines if slow
		go func(c *websocket.Conn, tm game.WsMessage) {
			ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
			defer cancel()
			_ = wsjson.Write(ctx, c, tm)
		}(conn, stateMsg)
	}
}
