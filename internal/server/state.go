package server

import (
	"context"
	"fmt"
	"net/http"
	"sync"
	"time"

	"github.com/coder/websocket"
	"github.com/coder/websocket/wsjson"
	"github.com/janpfeifer/GoSpot/internal/game"
	"k8s.io/klog/v2"
)

// ServerState manages all active tables and WebSockets.
type ServerState struct {
	mu           sync.RWMutex
	Tables       map[string]*game.Table
	TableClients map[string]map[*websocket.Conn]string // TableID -> Conn -> PlayerID
}

// NewServerState creates a new ServerState.
func NewServerState() *ServerState {
	return &ServerState{
		Tables:       make(map[string]*game.Table),
		TableClients: make(map[string]map[*websocket.Conn]string),
	}
}

// HandleWS handles an incoming WebSocket connection.
func (s *ServerState) HandleWS(w http.ResponseWriter, r *http.Request) {
	klog.Infof("HandleWS: Incoming connection from %s", r.RemoteAddr)
	conn, err := websocket.Accept(w, r, &websocket.AcceptOptions{
		InsecureSkipVerify: true,
	})
	if err != nil {
		klog.Errorf("HandleWS: Failed to accept websocket: %v", err)
		return
	}
	defer conn.CloseNow()

	// 1. Wait for join message from client
	var wsMsg game.WsMessage
	err = wsjson.Read(r.Context(), conn, &wsMsg)
	if err != nil {
		klog.Errorf("HandleWS: Failed to read initial msg: %v", err)
		return
	}
	klog.Infof("HandleWS: Received initial message type: %s", wsMsg.Type)

	genericMsg, err := wsMsg.Parse()
	if err != nil {
		klog.Errorf("HandleWS: Failed to parse message: %v", err)
		return
	}

	// Parse JoinMessage:
	var tableID string
	var player game.Player
	switch msg := genericMsg.(type) {
	case *game.JoinMessage:
		tableID = msg.TableID
		player = msg.Player
	default:
		klog.Errorf("HandleWS: Expected first message to be a Join message, got: %s", wsMsg.Type)
		return
	}

	// Ensure player ID
	if player.ID == "" { // Should be generated by client, but fallback
		player.ID = fmt.Sprintf("%d", time.Now().UnixNano())
	}

	klog.Infof("HandleWS: Player %s (%s) joining table %s", player.Name, player.ID, tableID)
	table := s.joinTable(tableID, &player, conn)

	// Disconnect handler
	defer s.leaveTable(tableID, conn)

	// 2. Read loop
	for {
		err = wsjson.Read(r.Context(), conn, &wsMsg)
		if websocket.CloseStatus(err) == websocket.StatusNormalClosure || websocket.CloseStatus(err) == websocket.StatusGoingAway {
			klog.Infof("HandleWS: Client disconnected normally")
			break
		}
		if err != nil {
			klog.Errorf("HandleWS: WS read error: %v", err)
			break
		}

		klog.Infof("HandleWS: Received message type: %s", wsMsg.Type)
		s.tableHandleMessage(conn, table, &player, wsMsg)
	}
}

func (s *ServerState) joinTable(tableID string, player *game.Player, conn *websocket.Conn) *game.Table {
	s.mu.Lock()
	defer s.mu.Unlock()

	table, ok := s.Tables[tableID]
	if !ok {
		klog.Infof("joinTable: Creating new table %s", tableID)
		// Auto-create table
		table = &game.Table{
			ID:      tableID,
			Name:    tableID, // Client can optionally rename later
			Players: make(map[string]*game.Player),
		}
		s.Tables[tableID] = table
		s.TableClients[tableID] = make(map[*websocket.Conn]string)
	}

	klog.Infof("joinTable: Adding player %s to table %s", player.Name, tableID)
	table.Players[player.ID] = player
	s.TableClients[tableID][conn] = player.ID

	s.broadcastStateLocked(tableID)
	return table
}

func (s *ServerState) leaveTable(tableID string, conn *websocket.Conn) {
	s.mu.Lock()
	defer s.mu.Unlock()

	clients, ok := s.TableClients[tableID]
	if !ok {
		return
	}

	playerID, ok := clients[conn]
	if ok {
		delete(clients, conn)
		table := s.Tables[tableID]
		if table != nil {
			delete(table.Players, playerID)
			// If table is empty, we could delete it, but memory is small
			if len(table.Players) == 0 {
				delete(s.Tables, tableID)
				delete(s.TableClients, tableID)
			} else {
				s.broadcastStateLocked(tableID)
			}
		}
	}
}

func (s *ServerState) tableHandleMessage(conn *websocket.Conn, table *game.Table, player *game.Player, msg game.WsMessage) {
	s.mu.Lock()
	defer s.mu.Unlock()

	switch msg.Type {
	case game.MsgTypeStart:
		if len(table.Players) >= 2 {
			table.Started = true
			s.broadcastStateLocked(table.ID)
		}
	}
}

// broadcastStateLocked broadcasts table state to all connections. Assumes m.mu is locked.
func (s *ServerState) broadcastStateLocked(tableID string) {
	table := s.Tables[tableID]
	stateMsg, err := game.NewWsMessage(game.MsgTypeState, game.StateMessage{
		Table: *table,
	})
	if err != nil {
		klog.Errorf("broadcastStateLocked: Failed to create state message: %v", err)
		return
	}

	for conn := range s.TableClients[tableID] {
		// Non-blocking quick send, or run in goroutines if slow
		go func(c *websocket.Conn, tm game.WsMessage) {
			ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
			defer cancel()
			_ = wsjson.Write(ctx, c, tm)
		}(conn, stateMsg)
	}
}
