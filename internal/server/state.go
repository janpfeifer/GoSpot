package server

import (
	"context"
	"encoding/json"
	"fmt"
	"math/rand"
	"net/http"
	"net/url"
	"sync"
	"time"

	"github.com/coder/websocket"
	"github.com/coder/websocket/wsjson"
	"github.com/janpfeifer/GoSpot/internal/game"
	"k8s.io/klog/v2"
)

// ServerState manages all active tables and WebSockets.
type ServerState struct {
	mu           sync.RWMutex
	Tables       map[string]*game.Table
	TableClients map[string]map[*websocket.Conn]string // TableID -> Conn -> PlayerID
}

// NewServerState creates a new ServerState.
func NewServerState() *ServerState {
	return &ServerState{
		Tables:       make(map[string]*game.Table),
		TableClients: make(map[string]map[*websocket.Conn]string),
	}
}

// HandleWS handles an incoming WebSocket connection.
func (s *ServerState) HandleWS(w http.ResponseWriter, r *http.Request) {
	klog.Infof("HandleWS: Incoming connection from %s", r.RemoteAddr)
	conn, err := websocket.Accept(w, r, &websocket.AcceptOptions{
		InsecureSkipVerify: true,
	})
	if err != nil {
		klog.Errorf("HandleWS: Failed to accept websocket: %v", err)
		return
	}
	defer conn.CloseNow()

	// 1. Wait for join message from client
	var wsMsg game.WsMessage
	err = wsjson.Read(r.Context(), conn, &wsMsg)
	if err != nil {
		klog.Errorf("HandleWS: Failed to read initial msg: %v", err)
		return
	}
	klog.Infof("HandleWS: Received initial message type: %s", wsMsg.Type)

	genericMsg, err := wsMsg.Parse()
	if err != nil {
		klog.Errorf("HandleWS: Failed to parse message: %v", err)
		return
	}

	// Parse JoinMessage:
	var tableID string
	var player game.Player
	switch msg := genericMsg.(type) {
	case *game.JoinMessage:
		tableID = msg.TableID
		player = msg.Player
	default:
		klog.Errorf("HandleWS: Expected first message to be a Join message, got: %s", wsMsg.Type)
		return
	}

	// Ensure player ID
	if player.ID == "" { // Should be generated by client, but fallback
		player.ID = fmt.Sprintf("%d", time.Now().UnixNano())
	}

	klog.Infof("HandleWS: Player %s (%s) joining table %s", player.Name, player.ID, tableID)
	table := s.joinTable(tableID, &player, conn)

	// Send initial Ping
	pingMsg, _ := game.NewWsMessage(game.MsgTypePing, game.PingMessage{
		ServerTime: time.Now().UnixNano(),
	})
	_ = wsjson.Write(r.Context(), conn, pingMsg)

	// Disconnect handler
	defer s.leaveTable(tableID, conn)

	// 2. Read loop
	for {
		err = wsjson.Read(r.Context(), conn, &wsMsg)
		if websocket.CloseStatus(err) == websocket.StatusNormalClosure || websocket.CloseStatus(err) == websocket.StatusGoingAway {
			klog.Infof("HandleWS: Client disconnected normally")
			break
		}
		if err != nil {
			klog.Errorf("HandleWS: WS read error: %v", err)
			break
		}

		klog.Infof("HandleWS: Received message type: %s", wsMsg.Type)
		s.tableHandleMessage(conn, table, &player, wsMsg)
	}
}

func (s *ServerState) joinTable(tableID string, player *game.Player, conn *websocket.Conn) *game.Table {
	s.mu.Lock()
	defer s.mu.Unlock()

	table, ok := s.Tables[tableID]
	if !ok {
		klog.Infof("joinTable: Creating new table %s", tableID)
		// Auto-create table
		table = &game.Table{
			ID:      tableID,
			Name:    tableID, // Client can optionally rename later
			Players: make([]*game.Player, 0),
		}
		s.Tables[tableID] = table
		s.TableClients[tableID] = make(map[*websocket.Conn]string)
	}

	klog.Infof("joinTable: Adding player %s to table %s", player.Name, tableID)

	// Check if already in
	found := false
	for _, p := range table.Players {
		if p.ID == player.ID {
			found = true
			break
		}
	}
	if !found {
		table.Players = append(table.Players, player)
	}
	s.TableClients[tableID][conn] = player.ID

	s.broadcastStateLocked(tableID)
	if table.Started {
		s.broadcastUpdateLocked(tableID)
	}
	return table
}

func (s *ServerState) leaveTable(tableID string, conn *websocket.Conn) {
	s.mu.Lock()
	defer s.mu.Unlock()

	clients, ok := s.TableClients[tableID]
	if !ok {
		return
	}

	playerID, ok := clients[conn]
	if ok {
		delete(clients, conn)
		table := s.Tables[tableID]
		if table != nil {
			// Remove from players slice
			for i, p := range table.Players {
				if p.ID == playerID {
					table.Players = append(table.Players[:i], table.Players[i+1:]...)
					break
				}
			}

			// If table is empty, we could delete it, but memory is small
			if len(table.Players) == 0 {
				delete(s.Tables, tableID)
				delete(s.TableClients, tableID)
			} else {
				s.broadcastStateLocked(tableID)
			}
		}
	}
}

func (s *ServerState) tableHandleMessage(conn *websocket.Conn, table *game.Table, player *game.Player, msg game.WsMessage) {
	s.mu.Lock()
	defer s.mu.Unlock()

	switch msg.Type {
	case game.MsgTypeStart:
		// Only creator (first player) can start
		if len(table.Players) >= 2 && table.Players[0].ID == player.ID {
			klog.Infof("tableHandleMessage: Creator %s starting game on table %s", player.Name, table.ID)
			deck := game.GenerateStandardDeck()
			deck.Shuffle()

			// 1. Initial Target Card
			table.TargetCard = deck[0]
			deck = deck[1:]

			// 2. Distribute Hand
			numPlayers := len(table.Players)
			cardsPerPlayer := len(deck) / numPlayers
			for i, p := range table.Players {
				p.Hand = deck[i*cardsPerPlayer : (i+1)*cardsPerPlayer]
				p.Score = len(p.Hand)
			}

			table.Started = true
			s.broadcastStateLocked(table.ID)
			s.broadcastUpdateLocked(table.ID)
			s.broadcastPingLocked(table.ID)
		}
	case game.MsgTypeCancel:
		// Only creator (first player) can cancel
		if len(table.Players) > 0 && table.Players[0].ID == player.ID {
			klog.Infof("tableHandleMessage: Creator %s cancelled table %s", player.Name, table.ID)
			// Notify everyone
			errorMsg, _ := game.NewWsMessage(game.MsgTypeError, game.ErrorMessage{
				Message: "Table was cancelled by creator.",
			})
			for c := range s.TableClients[table.ID] {
				go func(conn *websocket.Conn) {
					ctx, cancel := context.WithTimeout(context.Background(), time.Second*2)
					defer cancel()
					_ = wsjson.Write(ctx, conn, errorMsg)
					_ = conn.Close(websocket.StatusNormalClosure, "Table cancelled")
				}(c)
			}
			// Cleanup table
			delete(s.Tables, table.ID)
			delete(s.TableClients, table.ID)
		}
	case game.MsgTypePong:
		p, err := msg.Parse()
		if err != nil {
			klog.Errorf("tableHandleMessage: Failed to parse pong message: %v", err)
			return
		}
		pong, ok := p.(*game.PongMessage)
		if !ok {
			return
		}
		rtt := time.Now().UnixNano() - pong.ServerTime
		player.Latency = time.Duration(rtt / 2)
		klog.Infof("tableHandleMessage: Player %s latency: %v", player.Name, player.Latency)

		// Update in table.Players slice
		for _, tp := range table.Players {
			if tp.ID == player.ID {
				tp.Latency = player.Latency
				break
			}
		}
		s.broadcastStateLocked(table.ID)
	}
}

// broadcastUpdateLocked broadcasts individual game updates (top card, target card) to each client.
// Assumes s.mu is locked.
func (s *ServerState) broadcastUpdateLocked(tableID string) {
	table, ok := s.Tables[tableID]
	if !ok || !table.Started {
		return
	}

	for conn, playerID := range s.TableClients[tableID] {
		// Find player hand
		var player *game.Player
		for _, p := range table.Players {
			if p.ID == playerID {
				player = p
				break
			}
		}

		if player == nil || len(player.Hand) == 0 {
			continue
		}

		updateMsg, err := game.NewWsMessage(game.MsgTypeUpdate, game.UpdateMessage{
			TargetCard: table.TargetCard,
			TopCard:    player.Hand[0],
		})
		if err != nil {
			klog.Errorf("broadcastUpdateLocked: Failed to create update message: %v", err)
			continue
		}

		go func(c *websocket.Conn, um game.WsMessage) {
			ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
			defer cancel()
			_ = wsjson.Write(ctx, c, um)
		}(conn, updateMsg)
	}
}

// broadcastStateLocked broadcasts table state to all connections. Assumes m.mu is locked.
func (s *ServerState) broadcastStateLocked(tableID string) {
	table := s.Tables[tableID]
	stateMsg, err := game.NewWsMessage(game.MsgTypeState, game.StateMessage{
		Table: *table,
	})
	if err != nil {
		klog.Errorf("broadcastStateLocked: Failed to create state message: %v", err)
		return
	}

	for conn := range s.TableClients[tableID] {
		// Non-blocking quick send, or run in goroutines if slow
		go func(c *websocket.Conn, tm game.WsMessage) {
			ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
			defer cancel()
			_ = wsjson.Write(ctx, c, tm)
		}(conn, stateMsg)
	}
}

// broadcastPingLocked sends a ping to all connections on the table to measure latency.
// Assumes s.mu is locked.
func (s *ServerState) broadcastPingLocked(tableID string) {
	pingMsg, _ := game.NewWsMessage(game.MsgTypePing, game.PingMessage{
		ServerTime: time.Now().UnixNano(),
	})

	for conn := range s.TableClients[tableID] {
		go func(c *websocket.Conn, pm game.WsMessage) {
			ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
			defer cancel()
			_ = wsjson.Write(ctx, c, pm)
		}(conn, pingMsg)
	}
}

// HandleTestGame sets up a test game with 3 players (Moe, Larry, Curly) and redirects to the table.
func (s *ServerState) HandleTestGame(w http.ResponseWriter, r *http.Request) {
	s.mu.Lock()
	defer s.mu.Unlock()

	tableID := "ThreeStooges"
	klog.Infof("HandleTestGame: Setting up test game on table %s", tableID)

	table := &game.Table{
		ID:      tableID,
		Name:    tableID,
		Players: make([]*game.Player, 0, 3),
	}
	s.Tables[tableID] = table

	// Reset any existing connections to prevent accumulated bugs across tests
	s.TableClients[tableID] = make(map[*websocket.Conn]string)

	symbols := rand.Perm(57) // Assuming up to 57 symbols

	moe := &game.Player{ID: "moe", Name: "Moe", Symbol: symbols[0]}
	larry := &game.Player{ID: "larry", Name: "Larry", Symbol: symbols[1]}
	curly := &game.Player{ID: "curly", Name: "Curly", Symbol: symbols[2]}

	table.Players = append(table.Players, moe, larry, curly)

	// Start game
	deck := game.GenerateStandardDeck()
	deck.Shuffle()

	table.TargetCard = deck[0]
	deck = deck[1:]

	numPlayers := len(table.Players)
	cardsPerPlayer := len(deck) / numPlayers
	for i, p := range table.Players {
		p.Hand = deck[i*cardsPerPlayer : (i+1)*cardsPerPlayer]
		p.Score = len(p.Hand)
	}
	table.Started = true

	// Set cookie for Moe
	moeJSON, err := json.Marshal(moe)
	if err == nil {
		http.SetCookie(w, &http.Cookie{
			Name:  "gospot_player",
			Value: url.QueryEscape(string(moeJSON)),
			Path:  "/",
		})
	} else {
		klog.Errorf("HandleTestGame: Failed to marshal Moe: %v", err)
	}

	http.Redirect(w, r, "/table/"+tableID, http.StatusSeeOther)
}
