package server

import (
	"context"
	"encoding/json"
	"fmt"
	"math/rand"
	"net"
	"net/http"
	"net/url"
	"slices"
	"sync"
	"time"

	"github.com/coder/websocket"
	"github.com/coder/websocket/wsjson"
	"github.com/janpfeifer/GoSpot/internal/game"
	"k8s.io/klog/v2"
)

// ServerState manages all active tables and WebSockets.
type ServerState struct {
	Address      string
	mu           sync.RWMutex
	Tables       map[string]*game.Table
	TableClients map[string]map[*websocket.Conn]string // TableID -> Conn -> PlayerID

	// LocalDial allows local clients to connect directly to the server,
	// bypassing TCP. It is only non-nil if the server was started with NetPipeAddr.
	LocalDial func() (net.Conn, error)
}

// NewServerState creates a new ServerState.
func NewServerState() *ServerState {
	return &ServerState{
		Tables:       make(map[string]*game.Table),
		TableClients: make(map[string]map[*websocket.Conn]string),
	}
}

// HandleWS handles an incoming WebSocket connection.
func (s *ServerState) HandleWS(w http.ResponseWriter, r *http.Request) {
	klog.Infof("HandleWS: Incoming connection from %s", r.RemoteAddr)
	conn, err := websocket.Accept(w, r, &websocket.AcceptOptions{
		InsecureSkipVerify: true,
	})
	if err != nil {
		klog.Errorf("HandleWS: Failed to accept websocket: %v", err)
		return
	}
	defer conn.CloseNow()

	// 1. Wait for join message from client
	var wsMsg game.WsMessage
	err = wsjson.Read(r.Context(), conn, &wsMsg)
	if err != nil {
		klog.Errorf("HandleWS: Failed to read initial msg: %v", err)
		return
	}
	klog.Infof("HandleWS: Received initial message type: %s", wsMsg.Type)

	genericMsg, err := wsMsg.Parse()
	if err != nil {
		klog.Errorf("HandleWS: Failed to parse message: %v", err)
		return
	}

	// Parse JoinMessage:
	var tableID string
	var p game.Player
	switch msg := genericMsg.(type) {
	case *game.JoinMessage:
		tableID = msg.TableID
		p = msg.Player
	default:
		klog.Errorf("HandleWS: Expected first message to be a Join message, got: %s", wsMsg.Type)
		return
	}

	// Ensure player ID
	if p.ID == "" { // Should be generated by client, but fallback
		p.ID = fmt.Sprintf("%d", time.Now().UnixNano())
	}
	klog.Infof("HandleWS: Player %s (%s, Symbol: %d) joining table %s", p.Name, p.ID, p.Symbol, tableID)
	table, player := s.joinTable(tableID, p, conn)
	klog.Infof("HandleWS: Table: %s", table)

	// Send initial Ping
	pingMsg, _ := game.NewWsMessage(game.MsgTypePing, game.PingMessage{
		ServerTime: time.Now().UnixNano(),
	})
	_ = wsjson.Write(r.Context(), conn, pingMsg)

	// Disconnect handler
	defer s.leaveTable(table, conn)

	// 2. Read loop
	for {
		err = wsjson.Read(r.Context(), conn, &wsMsg)
		if websocket.CloseStatus(err) == websocket.StatusNormalClosure || websocket.CloseStatus(err) == websocket.StatusGoingAway {
			klog.Infof("HandleWS: Client disconnected normally")
			break
		}
		if err != nil {
			klog.Errorf("HandleWS: WS read error: %v", err)
			break
		}

		klog.Infof("HandleWS: Received message type: %s", wsMsg.Type)
		s.tableHandleMessage(conn, table, player, wsMsg)
	}
}

func (s *ServerState) joinTable(tableID string, p game.Player, conn *websocket.Conn) (*game.Table, *game.Player) {
	s.mu.Lock()
	defer s.mu.Unlock()

	table, ok := s.Tables[tableID]
	if !ok {
		klog.Infof("joinTable: Creating new table %s", tableID)
		// Auto-create table
		table = &game.Table{
			ID:      tableID,
			Name:    tableID, // Client can optionally rename later
			Players: make([]*game.Player, 0),
		}
		s.Tables[tableID] = table
		s.TableClients[tableID] = make(map[*websocket.Conn]string)
	}

	klog.Infof("joinTable: Adding player %q (Symbol: %d) to table %s", p.Name, p.Symbol, tableID)

	// Check if already in
	var player *game.Player
	for _, tp := range table.Players {
		if tp.ID == p.ID {
			player = tp
			break
		}
	}
	if player == nil {
		player = &game.Player{
			ID:     p.ID,
			Name:   p.Name,
			Symbol: p.Symbol,
		}
		table.Players = append(table.Players, player)
	} else {
		// Update name and symbol in case they changed or were missing
		player.Name = p.Name
		player.Symbol = p.Symbol
	}
	s.TableClients[tableID][conn] = player.ID

	s.broadcastStateLocked(table)
	if table.Started {
		s.broadcastUpdateLocked(table, nil)
	}
	return table, player
}

func (s *ServerState) leaveTable(table *game.Table, conn *websocket.Conn) {
	s.mu.Lock()
	defer s.mu.Unlock()

	clients, ok := s.TableClients[table.ID]
	if !ok {
		return
	}

	playerID, ok := clients[conn]
	if ok {
		delete(clients, conn)

		// Find the player
		var player *game.Player
		for _, p := range table.Players {
			if p.ID == playerID {
				player = p
				break
			}
		}

		// Remove from players slice only if they haven't finished (Score > 0)
		if player != nil && player.Score > 0 {
			for i, p := range table.Players {
				if p.ID == playerID {
					table.Players = slices.Delete(table.Players, i, i+1)
					break
				}
			}
		} else if player != nil {
			klog.Infof("Player %s disconnected but finished game, keeping in table.", player.Name)
		}

		// If table has no active connections, we delete it
		if len(clients) == 0 {
			klog.Infof("Table %s has no active connections, deleting.", table.ID)
			delete(s.Tables, table.ID)
			delete(s.TableClients, table.ID)
		} else {
			s.broadcastStateLocked(table)
		}
	}
}

// tableHandleMessage handles messages from a player in a table.
// It is called from the locked tableHandleMessage function.
func (s *ServerState) tableHandleMessage(conn *websocket.Conn, table *game.Table, player *game.Player, wsMsg game.WsMessage) {
	s.mu.Lock()
	defer s.mu.Unlock()

	msgAny, err := wsMsg.Parse()
	if err != nil {
		klog.Errorf("tableHandleMessage: Failed to parse message: %v", err)
		return
	}
	switch msg := msgAny.(type) {
	case *game.StartMessage:
		s.handleGameStart(table, player, msg)

	case *game.CancelMessage:
		// Only creator (first player) can cancel
		if len(table.Players) > 0 && table.Players[0].ID == player.ID {
			klog.Infof("tableHandleMessage: Creator %s cancelled table %s", player.Name, table.ID)
			// Notify everyone
			errorMsg, _ := game.NewWsMessage(game.MsgTypeError, game.ErrorMessage{
				Message: "Table was cancelled by creator.",
			})
			for c := range s.TableClients[table.ID] {
				go func(conn *websocket.Conn) {
					ctx, cancel := context.WithTimeout(context.Background(), time.Second*2)
					defer cancel()
					_ = wsjson.Write(ctx, conn, errorMsg)
					_ = conn.Close(websocket.StatusNormalClosure, "Table cancelled")
				}(c)
			}
			// Cleanup table
			delete(s.Tables, table.ID)
			delete(s.TableClients, table.ID)
		}
	case *game.PongMessage:
		rtt := time.Now().UnixNano() - msg.ServerTime
		player.Latency = time.Duration(rtt / 2)
		klog.Infof("tableHandleMessage: Player %s latency: %v", player.Name, player.Latency)

		// Update in table.Players slice
		for _, tp := range table.Players {
			if tp.ID == player.ID {
				tp.Latency = player.Latency
				break
			}
		}
		s.broadcastStateLocked(table)
	case *game.ClickMessage:
		s.handleClick(table, player, msg)
	}
}

func (s *ServerState) handleGameStart(table *game.Table, startingPlayer *game.Player, msg *game.StartMessage) {
	_ = msg
	// Only creator (first player) can start
	if len(table.Players) < 2 && table.Players[0].ID != startingPlayer.ID {
		klog.Errorf("handleGameStart: Not enough players to start game on table %s", table.ID)
		return
	}

	deck := game.GenerateStandardDeck()
	deck.Shuffle()

	// 1. Initial Target Card
	table.TargetCard = deck[0]
	deck = deck[1:]

	// 2. Distribute Hand
	numPlayers := len(table.Players)
	cardsPerPlayer := len(deck) / numPlayers
	for i, p := range table.Players {
		p.Hand = deck[i*cardsPerPlayer : (i+1)*cardsPerPlayer]
		p.Score = len(p.Hand)
	}

	table.Started = true
	table.StartTime = time.Now()
	table.Round = 1
	s.broadcastStateLocked(table)
	s.broadcastUpdateLocked(table, nil)
	s.broadcastPingLocked(table)
}

// handleClick message from player: it's called from the locked tableHandleMessage function.
func (s *ServerState) handleClick(table *game.Table, player *game.Player, msg *game.ClickMessage) {
	klog.Infof("handleClick: Player %s clicked symbol %d", player.Name, msg.Symbol)
	if !table.Started {
		klog.Errorf("handleClick: Player %s clicked symbol %d on non-started table", player.Name, msg.Symbol)
		return
	}
	if len(player.Hand) == 0 {
		klog.Errorf("handleClick: Player %s clicked symbol %d with no cards", player.Name, msg.Symbol)
		return // Cannot click if they have no cards
	}

	// 1. Validate that the symbol exists in both the TargetCard and the player's top card.
	validTarget := slices.Contains(table.TargetCard, msg.Symbol)
	validTop := slices.Contains(player.Hand[0], msg.Symbol)
	if !validTarget || !validTop {
		klog.Errorf("tableHandleMessage: Player %s made an invalid click", player.Name)
		// Ignore the click, relying on the frontend to handle the visual penalty.
		return
	}

	// Calculate latency compensation
	var maxLatency time.Duration
	for _, p := range table.Players {
		if p.Latency > maxLatency {
			maxLatency = p.Latency
		}
	}

	delay := max(maxLatency-player.Latency, 0)
	processTime := time.Now().Add(delay)
	klog.Infof("tableHandleMessage: Player %s valid click on %d. Delay %v, Target process %v", player.Name, msg.Symbol, delay, processTime)

	// Check if we should override the pending click
	if table.PendingClick == nil || processTime.Before(table.PendingClick.ProcessTime) {
		table.PendingClick = &game.PendingClick{
			PlayerID:    player.ID,
			ProcessTime: processTime,
			Symbol:      msg.Symbol,
			Round:       table.Round,
		}
		if table.ClickTimer != nil {
			table.ClickTimer.Stop()
		}
		if delay == 0 {
			// Process click immediately in a new goroutine to avoid deadlock.
			go s.processWinningClick(table, processTime)
		} else {
			table.ClickTimer = time.AfterFunc(delay, func() {
				s.processWinningClick(table, processTime)
			})
		}
	}
}

// processWinningClick is called when the delay timer for a winning click has expired.
func (s *ServerState) processWinningClick(table *game.Table, expectedProcessTime time.Time) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if !table.Started {
		return
	}

	click := table.PendingClick
	if click == nil || !click.ProcessTime.Equal(expectedProcessTime) {
		// Another click took precedence or it was already processed
		return
	}

	// Double check the round
	if click.Round != table.Round {
		return
	}

	// Find the winning player
	var clicker *game.Player
	for _, p := range table.Players {
		if p.ID == click.PlayerID {
			clicker = p
			break
		}
	}
	if clicker == nil || len(clicker.Hand) == 0 {
		return
	}

	duration := time.Since(table.StartTime)
	minutes := int(duration.Minutes())
	seconds := int(duration.Seconds()) % 60
	timeToClick := fmt.Sprintf("%02d:%02d", minutes, seconds)

	// Discard cards (3 if matched player symbol, 1 otherwise)
	scoringIDs := []string{clicker.ID}
	var finishers []string // players who finished their hand with this click.

	numToDiscard := 1
	if click.Symbol == clicker.Symbol {
		numToDiscard = game.BonusDiscards
	}
	if numToDiscard >= len(clicker.Hand) {
		numToDiscard = len(clicker.Hand)
		finishers = append(finishers, clicker.ID)
		clicker.TimeTaken = timeToClick
	}

	// The target card becomes the last discarded card from the player's hand.
	table.TargetCard = clicker.Hand[numToDiscard-1]
	clicker.Hand = clicker.Hand[numToDiscard:]
	clicker.Score = len(clicker.Hand)

	// Give bonus discards to other players whose matching symbol was clicked
	for _, p := range table.Players {
		if p.ID == clicker.ID {
			continue
		}
		if p.Symbol != click.Symbol || len(p.Hand) == 0 {
			continue
		}

		// Issue bonus discard to player with matching symbol:
		bonusDiscards := game.BonusDiscards
		if bonusDiscards >= len(p.Hand) {
			bonusDiscards = len(p.Hand)
			finishers = append(finishers, p.ID)
			p.TimeTaken = timeToClick
		}
		p.Hand = p.Hand[bonusDiscards:]
		p.Score = len(p.Hand)
		scoringIDs = append(scoringIDs, p.ID)
	}

	// Check if any player finished the game, if they were the first.
	if table.WinnerID == "" && len(finishers) > 0 {
		// Break the tie randomly.
		table.WinnerID = finishers[rand.Intn(len(finishers))]
	}
	table.Round++
	table.PendingClick = nil // Reset

	klog.Infof("processWinningClick: Player %s wins round %d on table %s! Discarded %d cards.",
		clicker.Name, table.Round, table.ID, numToDiscard)

	s.broadcastStateLocked(table)
	s.broadcastUpdateLocked(table, scoringIDs)
}

// broadcastUpdateLocked broadcasts individual game updates (top card, target card) to each client.
// Assumes s.mu is locked.
func (s *ServerState) broadcastUpdateLocked(table *game.Table, scoringIDs []string) {
	for conn, playerID := range s.TableClients[table.ID] {
		// Find player hand
		var player *game.Player
		for _, p := range table.Players {
			if p.ID == playerID {
				player = p
				break
			}
		}

		var topCard []int
		if player != nil && len(player.Hand) > 0 {
			topCard = player.Hand[0]
		}

		updateMsg, err := game.NewWsMessage(game.MsgTypeUpdate, game.UpdateMessage{
			TargetCard: table.TargetCard,
			TopCard:    topCard,
			Round:      table.Round,
			ScoringIDs: scoringIDs,
		})
		if err != nil {
			klog.Errorf("broadcastUpdateLocked: Failed to create update message: %v", err)
			continue
		}

		go func(c *websocket.Conn, um game.WsMessage) {
			ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
			defer cancel()
			_ = wsjson.Write(ctx, c, um)
		}(conn, updateMsg)
	}
}

// broadcastStateLocked broadcasts table state to all connections. Assumes m.mu is locked.
func (s *ServerState) broadcastStateLocked(table *game.Table) {
	stateMsg, err := game.NewWsMessage(game.MsgTypeState, game.StateMessage{
		Table: *table,
	})
	if err != nil {
		klog.Errorf("broadcastStateLocked: Failed to create state message: %v", err)
		return
	}

	for conn := range s.TableClients[table.ID] {
		// Non-blocking quick send, or run in goroutines if slow
		go func(c *websocket.Conn, tm game.WsMessage) {
			ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
			defer cancel()
			_ = wsjson.Write(ctx, c, tm)
		}(conn, stateMsg)
	}
}

// broadcastPingLocked sends a ping to all connections on the table to measure latency.
// Assumes s.mu is locked.
func (s *ServerState) broadcastPingLocked(table *game.Table) {
	pingMsg, _ := game.NewWsMessage(game.MsgTypePing, game.PingMessage{
		ServerTime: time.Now().UnixNano(),
	})

	for conn := range s.TableClients[table.ID] {
		go func(c *websocket.Conn, pm game.WsMessage) {
			ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
			defer cancel()
			_ = wsjson.Write(ctx, c, pm)
		}(conn, pingMsg)
	}
}

// HandleTestGame sets up a test game with 10 players and redirects to the table.
func (s *ServerState) HandleTestGame(w http.ResponseWriter, r *http.Request) {
	s.mu.Lock()
	defer s.mu.Unlock()

	tableID := "ThreeStooges"
	klog.Infof("HandleTestGame: Setting up test game on table %s", tableID)

	table := &game.Table{
		ID:      tableID,
		Name:    tableID,
		Players: make([]*game.Player, 0, 10),
	}
	s.Tables[tableID] = table

	// Reset any existing connections to prevent accumulated bugs across tests
	s.TableClients[tableID] = make(map[*websocket.Conn]string)

	symbols := rand.Perm(57) // Assuming up to 57 symbols

	moe := &game.Player{ID: "moe", Name: "Moe", Symbol: symbols[0]}
	larry := &game.Player{ID: "larry", Name: "Larry", Symbol: symbols[1]}
	curly := &game.Player{ID: "curly", Name: "Curly", Symbol: symbols[2]}

	bugs := &game.Player{ID: "bugs", Name: "Bugs Bunny", Symbol: symbols[3]}
	mickey := &game.Player{ID: "mickey", Name: "Mickey Mouse", Symbol: symbols[4]}
	spongebob := &game.Player{ID: "spongebob", Name: "SpongeBob", Symbol: symbols[5]}
	homer := &game.Player{ID: "homer", Name: "Homer Simpson", Symbol: symbols[6]}
	daffy := &game.Player{ID: "daffy", Name: "Daffy Duck", Symbol: symbols[7]}
	donald := &game.Player{ID: "donald", Name: "Donald Duck", Symbol: symbols[8]}
	scooby := &game.Player{ID: "scooby", Name: "Scooby-Doo", Symbol: symbols[9]}

	table.Players = append(table.Players, moe, larry, curly, bugs, mickey, spongebob, homer, daffy, donald, scooby)

	// Start game
	s.handleGameStart(table, moe, &game.StartMessage{})

	// Set cookie for Moe
	moeJSON, err := json.Marshal(moe)
	if err == nil {
		http.SetCookie(w, &http.Cookie{
			Name:  "gospot_player",
			Value: url.QueryEscape(string(moeJSON)),
			Path:  "/",
		})
	} else {
		klog.Errorf("HandleTestGame: Failed to marshal Moe: %v", err)
	}
	http.Redirect(w, r, "/table/"+tableID, http.StatusSeeOther)
}
